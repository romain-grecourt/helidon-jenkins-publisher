#!/bin/bash -e
#
# Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Path to this script
if [ -h "${0}" ] ; then
    readonly SCRIPT_PATH="$(readlink "${0}")"
else
    readonly SCRIPT_PATH="${0}"
fi
readonly SCRIPT_DIR=$(dirname ${SCRIPT_PATH})
readonly SCRIPT=$(basename ${SCRIPT_PATH})
source ${SCRIPT_DIR}/_common.sh

usage(){
  cat <<EOF

DESCRIPTION: Build a single layer image from a directory in the docker export format.

See https://github.com/moby/moby/blob/master/image/spec/v1.2.md

USAGE:

$(basename ${SCRIPT}) [OPTIONS] --path=PATH --name=NAME

  --path=PATH
          Path to the source directory to create the image.

  --name=NAME
          Image name of the form repository:tag.

OPTIONS:

  --output-file=PATH
          Path of the image tar file to create.

  --comment=TEXT
          Comment text to include in the metatada.

  --includes=INCLUDES
          List of relative include paths patterns.

  --target=PATH
          Target path of the included files in the created layer.

  --base=BASE_IMAGE
          Base image.

  --base-registry-url=URL
          Registry URL to pull the base image from. (e.g. https://registry.docker.io/v2)

  --base-registry-user=USERNAME
          Base registry user.

  --base-registry-password=PASSWORD
          Base registry password.

  --cmd=CMD
          Image command.

  --end=KEY=VAL
          Image environment variable.

  --load
          Load the created image to the Docker daemon.

EOF
  common_usage
}

# parse command line args
ARGS=( "${@}" )
ENV_ARRAY=( )
for ((i=0;i<${#ARGS[@]};i++))
{
    ARG=${ARGS[${i}]}
    case ${ARG} in
    "--path="*)
        readonly SOURCE_PATH=$(cd ${ARG#*=} ; pwd -P)
        ;;
    "--name="*)
        readonly IMAGE_NAME=${ARG#*=}
        ;;
    "--comment="*)
        readonly COMMENT=${ARG#*=}
        ;;
    "--includes="*)
        readonly INCLUDES=${ARG#*=}
        ;;
    "--target="*)
        TPATH=${ARG#*=}
        TPATH=$(remove_leading_slashes ${TPATH})
        TPATH=$(remove_trailing_slashes ${TPATH})
        TARGET_PATH=${TPATH}
        ;;
    "--base="*)
        readonly BASE_IMAGE=${ARG#*=}
        ;;
    "--base-registry-url="*)
        readonly BASE_REGISTRY_URL=${ARG#*=}
        ;;
    "--base-registry-user="*)
        readonly BASE_REGISTRY_UNAME=${ARG#*=}
        ;;
    "--base-registry-password="*)
        readonly BASE_REGISTRY_UPASSWD=${ARG#*=}
        ;;
    "--env="*)
        ENV_ARRAY[${#ENV_ARRAY[*]}]=${ARG#*=}
        ;;
    "--cmd="*)
        readonly IMAGE_CMD=${ARG#*=}
        ;;
    "--load")
        readonly LOAD=true
        ;;
    "--output-file="*)
        readonly OUTPUT_FILE=${ARG#*=}
        ;;
    *)
        common_process_args ${ARG}
        ;;
  esac
}

if [ -z "${IMAGE_NAME}" ] ; then
    echo "ERROR: --name option is required"
    exit 1
elif [ -z "${SOURCE_PATH}" ] ; then
    echo "ERROR: --path option is required"
    exit 1
fi

if [ -z "${LOAD}" ] ; then
    readonly LOAD=false
fi

if [ -z "${COMMENT}" ] ; then
    readonly COMMENT="created by ${SCRIPT}"
fi

common_init
if [ -z "${TAR_IMPL}" ] ; then
    echo "ERROR: unsupported tar implementation"
    exit 1
fi

echo "INFO: building ${IMAGE_NAME} ..."

readonly IMAGE_REPO=$(echo ${IMAGE_NAME} | cut -d ':' -f1)
readonly IMAGE_TAG=$(echo ${IMAGE_NAME} | cut -d ':' -f2)
echo "INFO: source = ${SOURCE_PATH}"
if [ ! -z "${TARGET_PATH}" ] ; then
    echo "INFO: target_path = ${TARGET_PATH}"
fi
echo "INFO: name = ${IMAGE_NAME}"
echo "INFO: image_repo = ${IMAGE_REPO}"
echo "INFO: image_tag = ${IMAGE_TAG}"

readonly IMAGE_DIR=$(mktemp -d ${WORKDIR}/imagedir.XXX)
echo "INFO: image_dir = ${IMAGE_DIR}"

LAYERS=( )
DIGESTS=( )
CMD_ARRAY=( )

gen_layer_metadata(){
    echo "1.0" > ${1}/${2}/VERSION
    cat << EOF > ${1}/${2}/json
{
  "id": "${2}",
  "architecture": "amd64",
  "os": "linux"
}
EOF
}

# Process base image
if [ ! -z "${BASE_IMAGE}" ] ; then
    readonly CACHEDIR="${SCRIPT_DIR}/.cache"
    readonly BASE_IMGDIR="${CACHEDIR}/$(echo ${BASE_IMAGE} | ${SHASUM} | cut -d ' ' -f1)"
    if ${DEBUG} ; then
        PULL_EXTRA_OPTS="--v"
    elif ${DEBUG2} ; then
        PULL_EXTRA_OPTS="--vv"
    fi
    if [ ! -z "${STDERR}" ] ; then
        PULL_EXTRA_OPTS="${PULL_EXTRA_OPTS} --stderr-file=${STDERR}"
    fi
    if [ ! -z "${BASE_REGISTRY_UNAME}" ] && [ ! -z "${BASE_REGISTRY_UPASSWD}" ] ; then
        PULL_EXTRA_OPTS="${PULL_EXTRA_OPTS} --user=${BASE_REGISTRY_UNAME} --password=${BASE_REGISTRY_UPASSWD}"
    fi
    if [ ! -e ${BASE_IMGDIR} ] ; then
        mkdir -p ${BASE_IMGDIR}
        pull ${PULL_EXTRA_OPTS} \
            --workdir=${WORKDIR} \
            --registry-url=${BASE_REGISTRY_URL} \
            --output-dir=${BASE_IMGDIR} \
            --name=${BASE_IMAGE}
    fi
    readonly BASE_IMAGE_ID=$(jq -r '.config.digest' ${BASE_IMGDIR}/manifest.json | cut -d ':' -f2)
    readonly BASE_CONFIG=${BASE_IMGDIR}/${BASE_IMAGE_ID}.json

    # get ENV from base image
    for env in $(jq -r '(.config.Env // [])[]' ${BASE_CONFIG})
    do
        found=false
        for ((i=0;i<${#ENV_ARRAY[@]};i++))
        {
            if [ "${ENV_ARRAY[${i}]%%=*}" = "${env%%=*}" ] ; then
                found=true
                break
            fi
        }
        if ! ${found} ; then
            ENV_ARRAY[${#ENV_ARRAY[*]}]=${env}
        fi
    done

    # get CMD from base image
    # override CMD if not empty
    if [ ${#CMD_ARRAY[*]} -gt 0 ] ; then
        CMD_ARRAY=( )
    fi
    for i in $(jq -r '(.config.Cmd // [])|to_entries | .[].key' ${BASE_CONFIG})
    do
        CMD_ARRAY[${#CMD_ARRAY[*]}]=$(jq -r ".config.Cmd[${i}]" ${BASE_CONFIG})
    done

    if ${LOAD} ; then
        for i in $(jq '.layers | to_entries | .[].key' ${BASE_IMGDIR}/manifest.json)
        do
            BASE_LAYER_ID=$(jq -r ".layers[${i}].digest" ${BASE_IMGDIR}/manifest.json | cut -d ':' -f2)
            BASE_LAYER_DIGEST=$(jq -r ".rootfs.diff_ids[${i}]" ${BASE_CONFIG})
            LAYERS[${#LAYERS[*]}]=${BASE_LAYER_ID}
            DIGESTS[${#DIGESTS[*]}]=${BASE_LAYER_DIGEST}

            mkdir ${IMAGE_DIR}/${BASE_LAYER_ID}
            cp ${BASE_IMGDIR}/${BASE_LAYER_ID}/layer.tar ${IMAGE_DIR}/${BASE_LAYER_ID}/layer.tar
            gen_layer_metadata ${IMAGE_DIR} ${BASE_LAYER_ID}
        done
    fi
fi

# Add image cmd
if [ ! -z "${IMAGE_CMD}" ] ; then
    # override CMD if not empty
    if [ ${#CMD_ARRAY[*]} -gt 0 ] ; then
        CMD_ARRAY=( )
    fi
    for cmd in ${IMAGE_CMD[*]}
    do
        CMD_ARRAY[${#CMD_ARRAY[*]}]=${cmd}
    done
fi

# Create a layer
readonly LAYER_ID=$(random_id)
LAYERS[${#LAYERS[*]}]=${LAYER_ID}
mkdir -p ${IMAGE_DIR}/${LAYER_ID}

# List all files to include
readonly TAR_MANIFEST=$(mktemp ${WORKDIR}/tarmanifest.XXX)
echo "INFO: tar_manifest = ${TAR_MANIFEST}"
if [ -z "${INCLUDES}" ] ; then
    find ${SOURCE_PATH} | sed "1d" > ${TAR_MANIFEST}
else
    for include in ${INCLUDES} ; do
        if [ -e "${SOURCE_PATH}/${include}" ] ; then
            find ${SOURCE_PATH}/${include} >> ${TAR_MANIFEST}
        else
            for elt in `ls ${SOURCE_PATH}/${include} 2> /dev/null || echo ""` ; do
                if [ -f ${elt} ] ; then
                    echo ${elt} >> ${TAR_MANIFEST}
                else
                    find ${SOURCE_PATH}/${elt} >> ${TAR_MANIFEST}
                fi
            done
        fi
    done
fi

# Create the layer.tar file
readonly LAYER_TAR="${IMAGE_DIR}/${LAYER_ID}/layer.tar"
echo "INFO: creating ${LAYER_TAR}"

if [ "${TAR_IMPL}" = "bsd" ] ; then
    # BSD tar: use a view directory with a symbolic link
    readonly TARVIEW=$(mktemp -d ${WORKDIR}/tarview.XXX)/view
    mkdir -p $(dirname ${TARVIEW}/${TARGET_PATH})
    if [ -z "${TARGET_PATH}" ] ; then
        ln -fs ${SOURCE_PATH} ${TARVIEW}
    else
        ln -fs ${SOURCE_PATH} ${TARVIEW}/${TARGET_PATH}
        TARGET_PATH_PREFIX="${TARGET_PATH}/"
    fi
    while read f ; do
        if [ ! -z "${f}" ] && [ -f "${f}" ] ; then
            echo "${f}" | sed s@${SOURCE_PATH}/@${TARGET_PATH_PREFIX}@g
        fi
    done < ${TAR_MANIFEST} | tar -cvpf ${LAYER_TAR} --files-from - -C ${TARVIEW} >&2
else
    # GNU tar: use the transform no-recursion options
    tar -cvpf ${LAYER_TAR} \
        --files-from ${TAR_MANIFEST} \
        --transform=s@$(remove_leading_slashes ${SOURCE_PATH})@${TARGET_PATH}@g \
        --no-recursion >&2
fi

gen_layer_metadata ${IMAGE_DIR} ${LAYER_ID}

readonly CREATED_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
readonly LAYER_DIGEST=$(${SHASUM} ${IMAGE_DIR}/${LAYER_ID}/layer.tar | cut -d ' ' -f1)
DIGESTS[${#DIGESTS[*]}]="sha256:${LAYER_DIGEST}"

cat << EOF > ${IMAGE_DIR}/config.json
{
  "architecture": "amd64",
  "created": "${CREATED_DATE}",
  "comment": "${COMMENT}",
  "os": "linux",
  "config": {
     "Env": [
$(for ((i=0;i<${#ENV_ARRAY[@]};i++))
{
    printf "      \"${ENV_ARRAY[${i}]}\""
    if [ "${i}" = "$((${#ENV_ARRAY[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
     ],
     "Cmd": [
$(for ((i=0;i<${#CMD_ARRAY[@]};i++))
{
    printf "      \"${CMD_ARRAY[${i}]}\""
    if [ "${i}" = "$((${#CMD_ARRAY[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
     ]
  },
  "rootfs": {
    "type": "layers",
    "diff_ids": [
$(for ((i=0;i<${#DIGESTS[@]};i++))
{
    printf "      \"${DIGESTS[${i}]}\""
    if [ "${i}" = "$((${#DIGESTS[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
    ]
  }
}
EOF

readonly IMAGE_ID=$(${SHASUM} ${IMAGE_DIR}/config.json | cut -d ' ' -f1)
mv ${IMAGE_DIR}/config.json ${IMAGE_DIR}/${IMAGE_ID}.json

cat << EOF > ${IMAGE_DIR}/repositories
{
  "${IMAGE_REPO}": {
    "${IMAGE_TAG}": "${CACHE_ID}"
  }
}
EOF

cat << EOF > ${IMAGE_DIR}/manifest.json
[
  {
    "Config": "${IMAGE_ID}.json",
    "RepoTags": [
      "${IMAGE_REPO}:${IMAGE_TAG}"
    ],
    "Layers": [
$(for ((i=0;i<${#LAYERS[@]};i++))
{
    printf "      \"${LAYERS[${i}]}/layer.tar\""
    if [ "${i}" = "$((${#LAYERS[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
    ]
  }
]
EOF

if [ ! -z "${OUTPUT_FILE}" ] ; then
    readonly IMAGE_TAR="${OUTPUT_FILE}"
else
    readonly IMAGE_TAR=$(mktemp ${WORKDIR}/imagetar.XXX).tar
fi

echo "INFO: creating ${IMAGE_TAR}"
tar -cvf ${IMAGE_TAR} -C ${IMAGE_DIR} . >&2

# load the image
if ${LOAD} ; then
    echo "INFO: loading the image to Docker"
    docker load -i ${IMAGE_TAR} 1>&2
fi

if ${LOAD} && [ -z "${OUTPUT_FILE}" ] ; then
    echo "INFO: cleaning up image tar..."
    rm -f ${IMAGE_TAR}
fi
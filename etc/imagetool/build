#!/bin/bash -e
#
# Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Path to this script
if [ -h "${0}" ] ; then
    readonly SCRIPT_PATH="$(readlink "${0}")"
else
    readonly SCRIPT_PATH="${0}"
fi
readonly SCRIPT_DIR=$(dirname ${SCRIPT_PATH})
readonly SCRIPT=$(basename ${SCRIPT_PATH})
source ${SCRIPT_DIR}/common.sh

usage(){
  cat <<EOF

DESCRIPTION: Build a single layer image from a directory

USAGE:

$(basename ${SCRIPT}) [OPTIONS] --path=PATH --name=NAME

  --path=PATH
          Path to the source directory to create the image.

  --name=NAME
          Image name of the form repository:tag.

OPTIONS:

  --output-file=PATH
          Path of the image tar file to create.

  --comment=TEXT
          Comment text to include in the metatada.

  --includes=INCLUDES
          List of relative include paths patterns.

  --target=PATH
          Target path of the included files in the created layer.

  --base=BASE_IMAGE
          Base image.

  --base-registry-url=URL
          Registry URL to pull the base image from. (e.g. https://registry.docker.io/v2)

  --base-registry-user=USERNAME
          Base registry user.

  --base-registry-password=PASSWORD
          Base registry password.

  --cmd=CMD
          Image command.

  --end=KEY=VAL
          Image environment variable.

  --load
          Load the created image to the Docker daemon.

EOF
  common_usage
}

# parse command line args
ARGS=( "${@}" )
ENV_ARRAY=( )
for ((i=0;i<${#ARGS[@]};i++))
{
    ARG=${ARGS[${i}]}
    case ${ARG} in
    "--path="*)
        readonly SOURCE_PATH=$(cd ${ARG#*=} ; pwd -P)
        ;;
    "--name="*)
        readonly IMAGE_NAME=${ARG#*=}
        ;;
    "--comment="*)
        readonly COMMENT=${ARG#*=}
        ;;
    "--includes="*)
        readonly INCLUDES=${ARG#*=}
        ;;
    "--target="*)
        TPATH=${ARG#*=}
        TPATH=$(remove_leading_slashes ${TPATH})
        TPATH=$(remove_trailing_slashes ${TPATH})
        readonly TARGET_PATH=${TPATH}
        ;;
    "--base="*)
        readonly BASE_IMAGE=${ARG#*=}
        ;;
    "--base-registry-url="*)
        readonly BASE_REGISTRY_URL=${ARG#*=}
        ;;
    "--base-registry-user="*)
        readonly BASE_REGISTRY_UNAME=${ARG#*=}
        ;;
    "--base-registry-password="*)
        readonly BASE_REGISTRY_UPASSWD=${ARG#*=}
        ;;
    "--env="*)
        ENV_ARRAY[${#ENV_ARRAY[*]}]=${ARG#*=}
        ;;
    "--cmd="*)
        readonly IMAGE_CMD=${ARG#*=}
        ;;
    "--load")
        readonly LOAD=true
        ;;
    "--output-file="*)
        readonly OUTPUT_FILE=${ARG#*=}
        ;;
    *)
        common_process_args ${ARG}
        ;;
  esac
}

if [ -z "${IMAGE_NAME}" ] ; then
    echo "ERROR: --name option is required"
    exit 1
elif [ -z "${SOURCE_PATH}" ] ; then
    echo "ERROR: --path option is required"
    exit 1
fi

if [ -z "${LOAD}" ] ; then
    readonly LOAD=false
fi

if [ -z "${COMMENT}" ] ; then
    readonly COMMENT="created by ${SCRIPT}"
fi

common_init
if [ -z "${TAR_IMPL}" ] ; then
    echo "ERROR: unsupported tar implementation"
    exit 1
fi

echo "INFO: building ${IMAGE_NAME} ..."

readonly IMAGE_REPO=$(echo ${IMAGE_NAME} | cut -d ':' -f1)
readonly IMAGE_TAG=$(echo ${IMAGE_NAME} | cut -d ':' -f2)
readonly WORKDIR=$(mktemp -d -t "XXX${SCRIPT}")
echo "INFO: source = ${SOURCE_PATH}"
if [ ! -z "${TARGET_PATH}" ] ; then
    echo "INFO: target_path = ${TARGET_PATH}"
fi
echo "INFO: name = ${IMAGE_NAME}"
echo "INFO: image_repo = ${IMAGE_REPO}"
echo "INFO: image_tag = ${IMAGE_TAG}"
echo "INFO: workdir = ${WORKDIR}"

# contains all layer cache ids
LAYERS=( )
# contains all layer digests
DIGESTS=( )

# contains the command
CMD_ARRAY=( )

process_base_layer() {
    local image_dir=${1}
    local digest=${2}

    # copy layer tar
    local layer_id=$(random_id)
    mkdir ${WORKDIR}/${layer_id}
    cp ${image_dir}/${digest##*:}/layer.tar ${WORKDIR}/${layer_id}/layer.tar
    DIGESTS[${#DIGESTS[*]}]="sha256:$(${SHASUM} ${WORKDIR}/${layer_id}/layer.tar | cut -d ' ' -f1)"

    # Add layer metadata
    echo "1.0" > ${WORKDIR}/${layer_id}/VERSION
    cat << EOF > ${WORKDIR}/${layer_id}/json
{
  "id": "${layer_id}",
  "architecture": "amd64",
  "os": "linux"
}
EOF
    LAYERS[${#LAYERS[*]}]=${layer_id}

    # get ENV from base image
    local base_config="${image_dir}/$(cat ${image_dir}/manifest.json | jq -r '.config.digest' | cut -d ':' -f2).json"
    for env in $(cat ${base_config} | jq -r '(.config.Env // [])[]')
    do
        found=false
        for ((i=0;i<${#ENV_ARRAY[@]};i++))
        {
            if [ "${ENV_ARRAY[${i}]%%=*}" = "${env%%=*}" ] ; then
                found=true
                break
            fi
        }
        if ! ${found} ; then
            ENV_ARRAY[${#ENV_ARRAY[*]}]=${env}
        fi
    done

    # get CMD from base image
    # override CMD if not empty
    if [ ${#CMD_ARRAY[*]} -gt 0 ] ; then
        CMD_ARRAY=( )
    fi
    for i in $(cat ${base_config} | jq -r '(.config.Cmd // [])|to_entries | .[].key')
    do
        CMD_ARRAY[${#CMD_ARRAY[*]}]=$(cat ${base_config} | jq -r ".config.Cmd[${i}]")
    done
}

# Process base image
if [ ! -z "${BASE_IMAGE}" ] ; then
    readonly CACHEDIR="${SCRIPT_DIR}/.cache"
    readonly BASE_IMGDIR="${CACHEDIR}/$(echo ${BASE_IMAGE} | ${SHASUM} | cut -d ' ' -f1)"
    if ${DEBUG} ; then
        PULL_EXTRA_OPTS="--v"
    elif ${DEBUG2} ; then
        PULL_EXTRA_OPTS="--vv"
    fi
    if [ ! -z "${BASE_REGISTRY_UNAME}" ] && [ ! -z "${BASE_REGISTRY_UPASSWD}" ] ; then
        PULL_EXTRA_OPTS="${PULL_EXTRA_OPTS} --user=${BASE_REGISTRY_UNAME} --password=${BASE_REGISTRY_UPASSWD}"
    fi
    if [ ! -e ${BASE_IMGDIR} ] ; then
        mkdir -p ${BASE_IMGDIR}
        bash ${SCRIPT_DIR}/pull ${PULL_EXTRA_OPTS} \
            --registry-url=${BASE_REGISTRY_URL} \
            --output-dir=${BASE_IMGDIR} \
            --name=${BASE_IMAGE}
    fi
    readonly BASE_MANIFEST
    for i in `cat ${BASE_IMGDIR}/manifest.json | jq '.layers | to_entries | .[].key'`
    do
        process_base_layer ${BASE_IMGDIR} $(cat ${BASE_IMGDIR}/manifest.json | jq -r ".layers[${i}].digest")
    done
fi

# Add image cmd
if [ ! -z "${IMAGE_CMD}" ] ; then
    # override CMD if not empty
    if [ ${#CMD_ARRAY[*]} -gt 0 ] ; then
        CMD_ARRAY=( )
    fi
    for cmd in ${IMAGE_CMD[*]}
    do
        CMD_ARRAY[${#CMD_ARRAY[*]}]=${cmd}
    done
fi

# Create a layer
readonly LAYER_ID=$(random_id)
mkdir -p ${WORKDIR}/${LAYER_ID}

# List all files to include
readonly TAR_MANIFEST=$(mktemp -t "XXXtar-manifest")
echo "INFO: tar_manifest = ${TAR_MANIFEST}"
if [ -z "${INCLUDES}" ] ; then
    find ${SOURCE_PATH} -type f | sed s@"${SOURCE_PATH}/"@@g > ${TAR_MANIFEST}
else
    for include in ${INCLUDES} ; do
        if [ -e "${SOURCE_PATH}/${include}" ] ; then
            find ${SOURCE_PATH}/${include} -type f | sed s@"${SOURCE_PATH}/"@@g >> ${TAR_MANIFEST}
        else
            for elt in `ls ${SOURCE_PATH}/${include} 2> /dev/null || echo ""` ; do
                if [ -f ${elt} ] ; then
                    echo ${elt} | sed s@"${SOURCE_PATH}/"@@g >> ${TAR_MANIFEST}
                else
                    find ${SOURCE_PATH}/${elt} -type f | sed s@"${SOURCE_PATH}/"@@g >> ${TAR_MANIFEST}
                fi
            done
        fi
    done
fi

# Create the layer.tar file
readonly LAYER_TAR="${WORKDIR}/${LAYER_ID}/layer.tar"
echo "INFO: creating ${LAYER_TAR}"
readonly TARVIEW=$(mktemp -d -t "XXX${SCRIPT}")/view
mkdir -p $(dirname ${TARVIEW}/${TARGET_PATH})

if [ -z "${TARGET_PATH}" ] ; then
    ln -fs ${SOURCE_PATH} ${TARVIEW}
else 
    ln -fs ${SOURCE_PATH} ${TARVIEW}/${TARGET_PATH}
fi

if [ "${TAR_IMPL}" = "bsd" ] ; then
    TAR_OPTS="-C ${TARVIEW}"
else
    TAR_OPTS="--transform=s@^.*/view/@@g"
    TARGET_PATH_PREFIX="${TARVIEW}/"
fi

if ! [ -z "${TARGET_PATH}" ] ; then
    TARGET_PATH_PREFIX="${TARGET_PATH_PREFIX}${TARGET_PATH}/"
fi

while read f ; do
    echo "${TARGET_PATH_PREFIX}${f}"
done < ${TAR_MANIFEST} | tar -cvf ${LAYER_TAR} --files-from - ${TAR_OPTS}

# Add layer metadata
echo "1.0" > ${WORKDIR}/${LAYER_ID}/VERSION
cat << EOF > ${WORKDIR}/${LAYER_ID}/json
{
  "id": "${LAYER_ID}",
  "architecture": "amd64",
  "os": "linux"
}
EOF

readonly CREATED_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
readonly LAYER_DIGEST=$(${SHASUM} ${WORKDIR}/${LAYER_ID}/layer.tar | cut -d ' ' -f1)
LAYERS[${#LAYERS[*]}]=${LAYER_ID}
DIGESTS[${#DIGESTS[*]}]="sha256:${LAYER_DIGEST}"

cat << EOF > ${WORKDIR}/config.json
{
  "architecture": "amd64",
  "created": "${CREATED_DATE}",
  "comment": "${COMMENT}",
  "os": "linux",
  "config": {
     "Env": [
$(for ((i=0;i<${#ENV_ARRAY[@]};i++))
{
    printf "      \"${ENV_ARRAY[${i}]}\""
    if [ "${i}" = "$((${#ENV_ARRAY[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
     ],
     "Cmd": [
$(for ((i=0;i<${#CMD_ARRAY[@]};i++))
{
    printf "      \"${CMD_ARRAY[${i}]}\""
    if [ "${i}" = "$((${#CMD_ARRAY[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
     ]
  },
  "rootfs": {
    "type": "layers",
    "diff_ids": [
$(for ((i=0;i<${#DIGESTS[@]};i++))
{
    printf "      \"${DIGESTS[${i}]}\""
    if [ "${i}" = "$((${#DIGESTS[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
    ]
  }
}
EOF

readonly IMAGE_ID=$(${SHASUM} ${WORKDIR}/config.json | cut -d ' ' -f1)
mv ${WORKDIR}/config.json ${WORKDIR}/${IMAGE_ID}.json

cat << EOF > ${WORKDIR}/repositories
{
  "${IMAGE_REPO}": {
    "${IMAGE_TAG}": "${CACHE_ID}"
  }
}
EOF

cat << EOF > ${WORKDIR}/manifest.json
[
  {
    "Config": "${IMAGE_ID}.json",
    "RepoTags": [
      "${IMAGE_REPO}:${IMAGE_TAG}"
    ],
    "Layers": [
$(for ((i=0;i<${#LAYERS[@]};i++))
{
    printf "      \"${LAYERS[${i}]}/layer.tar\""
    if [ "${i}" = "$((${#LAYERS[@]}-1))" ] ; then printf "\n" ; else printf ",\n" ; fi
})
    ]
  }
]
EOF

if [ ! -z "${OUTPUT_FILE}" ] ; then
    readonly IMAGE_TAR="${OUTPUT_FILE}"
else
    readonly IMAGE_TAR="$(mktemp -t XXX${SCRIPT}).tar"
fi

echo "INFO: creating ${IMAGE_TAR}"
tar -cvf ${IMAGE_TAR} -C ${WORKDIR} .

# load the image
if ${LOAD} ; then
    echo "INFO: loading the image to Docker"
    if ${DEBUG} || ${DEBUG2}; then
        docker load -i ${IMAGE_TAR}
    else
        docker load -i ${IMAGE_TAR} 1> /dev/null
    fi
fi

if ${LOAD} && [ -z "${OUTPUT_FILE}" ] ; then
    echo "INFO: cleaning up image tar..."
    rm -f ${IMAGE_TAR}
fi